# Chapter 1: Introduction

## 1.1 Project Overview

The ABN Meal App is a dynamic and modern web application that showcases the developer's skills and abilities. The project has limited features, but its main objective is to retrieve meal data from the Meal DB API.

The frontend of the project is built using `Vue 3` and `TypeScript` technologies, and is completely styled using `scss`.

## 1.2 Folder Structure

Folder structure:

```bash
├── README.md
├── index.html
├── jest.config.js
├── package-lock.json
├── package.json
├── public
│   └── favicon.ico
├── src
│   ├── App.vue
│   ├── assets
│   │   ├── css
│   │   │   ├── _variables.scss
│   │   │   └── app.scss
│   │   └── images
│   │       └── logo.png
│   ├── env.d.ts
│   ├── lib
│   │   ├── components
│   │   │   ├── home
│   │   │   │   ├── VAdvancedSearchModal.vue
│   │   │   │   ├── VRandomMeal.vue
│   │   │   │   └── VSearchGrid.vue
│   │   │   ├── meal
│   │   │   │   ├── VIngredientList.vue
│   │   │   │   ├── VMealImage.vue
│   │   │   │   ├── VMealSuggestions.vue
│   │   │   │   └── VMealVideo.vue
│   │   │   └── shared
│   │   │       ├── VMealCard.vue
│   │   │       ├── VMealGrid.vue
│   │   │       └── VTypography.vue
│   │   ├── constants
│   │   │   └── index.ts
│   │   ├── hooks
│   │   │   ├── useFetchSuggestions.ts
│   │   │   ├── useRandomMeal.ts
│   │   │   ├── useSearchMealById.ts
│   │   │   └── useSearchMeals.ts
│   │   ├── http
│   │   │   └── axios.ts
│   │   ├── services
│   │   │   └── meal-service.ts
│   │   └── types
│   │       └── index.ts
│   ├── main.ts
│   ├── router
│   │   └── index.ts
│   └── views
│       ├── HomeView.vue
│       └── MealView.vue
├── tests
├── tsconfig.json
└── vite.config.ts
```

The folder structure of the project is organized in a way that makes it easy to navigate and understand the different components of the application. The following is a list of the main folders and subfolders in the project along with the rationale behind the organization:

- `public`: This folder contains static assets like the favicon. These files are served directly by the web server and do not go through any build process.

- `src`: This is the main source directory for the application. All the Vue components, services, hooks, and other application logic reside here. The structure inside the src folder is organized as follows:

  - `App.vue`: This is the main application component that serves as the entry point for the application.

  - `assets`: This folder contains application-wide assets like stylesheets and images. The css subfolder holds global styles and variables, while the images subfolder contains image files.

  - `env.d.ts`: This file contains type declarations for environment variables, providing type safety and autocompletion.

  - `lib`: This folder serves as a container for various application modules:

    - `components`: This subfolder contains all the Vue components organized by feature. The home and meal folders contain components specific to those features, while the shared folder contains reusable components.

    - `constants`: This subfolder holds constant values used throughout the application, such as API endpoints and other configuration values.

    - `hooks`: This subfolder contains custom hooks for managing and sharing state and side effects across components.

    - `http`: This subfolder contains the configuration for the HTTP client (axios) used to make API requests.

    - `services`: This subfolder contains service classes that encapsulate business logic and interact with external APIs.

    - `types`: This subfolder contains TypeScript type definitions for various entities used in the application.

  - `main.ts`: This is the entry point for the application's JavaScript code. It initializes the Vue app, configures the router, and mounts the app to the DOM.

  - `router`: This folder contains the configuration for the application's routing, making it easy to manage and navigate between pages.

  - `views`: This folder holds the top-level Vue components that represent entire pages in the application. These components are connected to the router.

- `tests`: This folder contains the configuration and test files for unit and integration testing.

- `tsconfig.json`: This file contains the TypeScript configuration for the project.

- `vite.config.ts`: This file contains the configuration for the Vite build tool and development server.

- `package-lock.json`: This file is generated by package manager npm to ensure consistent dependency installation across environments.

- This folder structure promotes a clear separation of concerns, making it easy to understand and navigate the application. Each folder and subfolder has a specific purpose, which simplifies the process of finding, adding, or modifying components and other code. This organization also scales well as the application grows, providing a solid foundation for future development.

# Chapter 2: Getting Started

## 2.1 Prerequisites

Before you start using the ABN Meal App, you need to have the following software installed on your computer:

- Node.js (version 10 or later)
- NPM (version 6 or later)
- Git

## 2.2 Installation

To install the ABN Meal App Frontend, you need to follow these steps:

- Clone the repository to your local machine using the following command:

```bash
git clone https://github.com/Tobiasltd/abn-meal-app.git
```

- Change into the project directory by running the following command:

```bash
cd frontend
```

- Install the required dependencies using the following command:

```bash
npm install
```

## 2.3 Starting the Application

To start the application, use the following commands:

```bash
npm run build
npm run preview
```

The application should now be running on port 4173 and can be accessed by going to http://localhost:4173.

# Chapter 3: Technical Architecture and Design Pattern

## 3.1 Frontend Architecture

The frontend of the ABN Meal App is built using Vue 3, as requested by the assignment.

## 3.2 Design Pattern

### Custom Hooks and Service-based Architecture

This project follows the "Custom Hooks and Service-based Architecture" design pattern. This pattern combines the use of custom hooks for encapsulating state management logic with service classes for handling API calls and business logic. It promotes separation of concerns, modularity, and testability in the application's architecture. The use of custom hooks for state management with Vue-query and services for API interactions is an example of how this pattern can be applied in a modern Vue.js application.

### Component-based Design

Another notable design pattern used in this project is the "Component-based Design" pattern. This pattern involves organizing the UI into a hierarchy of reusable components, each responsible for rendering a specific part of the application's interface. The project structure reflects this pattern with dedicated directories for `home`, `meal`, and `shared` components. This organization promotes reusability, maintainability, and a clear separation of concerns between different parts of the application.

### File-type Based Folder Structure

In this project, a "File-type Based Folder Structure" is used, which organizes the codebase into separate folders based on the different types of files, such as `components`, `hooks`, `http`, and `services`. This approach is particularly suitable for small projects, as it provides a simple and intuitive organization that is easy to navigate and maintain. By grouping similar file types together, developers can quickly locate the relevant files when working on a specific aspect of the application. The file-type based structure also allows for better code organization and separation of concerns, as it keeps related functionalities together in their respective folders.d maintained independently from the rest of the application.

## 3.3 State Management

All server state management is done through vue-query.

Vue-query is a powerful library for managing server state in Vue applications. By leveraging hooks and caching, it simplifies the process of fetching, caching, and synchronizing server data. The benefits of choosing Vue-query as the state management solution for this project include:

1. Simplified data fetching: Vue-query provides a set of hooks that make it easy to fetch, cache, and update data from APIs. This approach allows components to be self-contained and reduces the need for boilerplate code associated with manual data fetching and management.

2. Automatic caching: Vue-query automatically caches fetched data, reducing the number of redundant API calls and improving application performance. Cached data can be easily shared between components, eliminating the need to re-fetch data when navigating between pages.

3. Built-in synchronization: With Vue-query, synchronization of server data is built-in, and it's simple to configure. Components can easily refetch data when needed or when specific events occur, such as window focus or network reconnect. This ensures that the displayed data is always up-to-date with the server state.

4. Reduced complexity: By using Vue-query, the need for a separate state management library like Vuex or Pinia is eliminated. This simplifies the application architecture and reduces the overall learning curve for developers. Components can directly consume data from hooks, reducing the need for complex state management patterns.

5. Optimistic updates: Vue-query supports optimistic updates, allowing the application to update its UI immediately based on user input and then synchronize with the server in the background. This provides a smoother user experience and reduces the perceived latency of the application.

6. Easier testing and maintenance: By encapsulating data fetching and state management logic in hooks and services, testing becomes more straightforward. Components can be tested in isolation, and services can be mocked to verify their behavior. This modular approach also makes it easier to maintain and update the application as it grows.

In summary, the choice of using Vue-query for state management in this Vue 3 frontend application provides several benefits, including simplified data fetching, automatic caching, built-in synchronization, and reduced complexity. This leads to a more maintainable, performant, and developer-friendly application, while also enhancing the user experience.

As mentioned, there is no more need for Pinia or Vuex with Vue-query. Therefore, the only other forms of state management used in this project are provided by the vue framework and consist of component based state management.

# Chapter 4: Features

This Vue.js frontend application offers several useful features to enhance the user experience while searching for meal recipes.

## Homepage

### Random Meal

The application displays a random meal on the homepage, providing users with a quick and easy way to discover new recipes without having to search for them. This feature adds a touch of serendipity to the user experience, encouraging exploration and potentially sparking interest in dishes the user might not have otherwise encountered.

### Search Meal

Users can search for meals using various criteria, such as keywords, categories, ingredients, names, or regions. This feature offers flexibility in meal discovery, allowing users to refine their search based on personal preferences or dietary requirements.

### Advanced Search

For users seeking more precise search results, the `advanced search BONUS feature` enables them to filter meals based on multiple criteria. Since TheMealDB does not inherently support this functionality, custom logic was implemented to cross-reference results from four separate queries.

To test the advanced search feature, follow these steps:

a. Click the "Advanced Search" button to open the modal.

b. Enter "pie" in the search term field and press "Search." You will see numerous results.

c. Click the "Advanced Search" button again and add "beef" to the category field. The results will be narrowed down significantly.

d. Add "british" to the area field. One result will be removed.

e. Lastly, add "onion" to the ingredients field. You should now see only two results, demonstrating the effectiveness of the advanced search feature in refining search results based on multiple criteria.

## Meal Page

The meal page offers a detailed view of the selected meal recipe, providing users with all the information they need to prepare the dish successfully. The key elements of the meal page include:

### Recipe

The meal page provides users with clear cooking instructions and a list of required ingredients, ensuring a smooth preparation process. A high-quality image of the finished meal offers a visual reference, while a video tutorial, if available, provides additional guidance. These elements combine to create a comprehensive and informative resource for users to prepare their chosen dish with ease and confidence.

### Navigation

A link at the top of the meal page allows users to quickly and easily return to the homepage, ensuring seamless navigation throughout the application.

### Suggestions

An added `BONUS feature` on the meal page is the "Suggestions" section, which presents four recommended meals within the same category as the currently displayed meal. This encourages users to explore further recipes within their areas of interest and helps to make the application a more valuable resource for meal inspiration and discovery.

The meal page combines these elements to provide users with a comprehensive and informative resource for preparing their chosen dish, while also promoting further exploration of related recipes.
